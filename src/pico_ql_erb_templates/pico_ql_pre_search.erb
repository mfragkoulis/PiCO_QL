// Filters column values of virtual table <%= @name %>.
int <%= @name %>_search(sqlite3_vtab_cursor *cur, char *constr, sqlite3_value *val) {
    stlTable *stl = (stlTable *)cur->pVtab;
    (void)stl;	// Silence compiler unused variable warning
    stlTableCursor *stcsr = (stlTableCursor *)cur;
<%      if @base_var.length > 0 %>
    if (stcsr->isInstanceNULL) {   // Size 1 to print "(null)".
        stcsr->size = 1;
        return SQLITE_OK;
    }
<%        if @container_class.length > 0 %>
    if (stcsr->isInstanceEmpty) {  // Size 1 to print "(empty)".
        stcsr->size = 1;
        return SQLITE_OK;
    }
<%        end %>
<%      end %>
<%      if /\*/.match(@pointer) == nil %>
<%        sign_retype = "#{@signature}*" %>
<%        sign_untype = @signature %>
<%      else %>
<%        sign_retype = @signature %>
<%        sign_untype = @signature.chomp("*") %>
<%      end %>
    <%= sign_retype %> any_dstr = (<%= sign_retype %>)stcsr->source;
<%      if @container_class.length > 0 %>
    <%= sign_untype %>:: iterator iter;
<%      end %>
    int op, iCol, i = 0, count = 0, re = 0;
<%      if @base_var.length > 0 %>
    int size = stcsr->max_size;
<%      else %>
    int size;
    if (stl->zErr) {
        sqlite3_free(stl->zErr);
        return SQLITE_MISUSE;
    }
<%      end %>
    if (val == NULL) {
<%      if @base_var.length > 0 %>
<%        if @container_class.length > 0 %>
        for (int j = 0; j < size; j++) {
            stcsr->resultSet[j] = j;
            stcsr->size++;
	}
        assert(stcsr->size <= stcsr->max_size);
        assert(&stcsr->resultSet[stcsr->size] <= &stcsr->resultSet[size]);
<%        else %>
        stcsr->size++;
<%        end %>
<%      else %>
        printf("Searching VT <%= @name %> with no BASE constraint...makes no sense.\n");
        return SQLITE_MISUSE;
<%      end %>
    } else {
        check_alloc((const char *)constr, op, iCol);
<%      if @base_var.length == 0 %>
        if (equals_base(stl->azColumn[iCol])) {
	    if (!strcmp((const char *)sqlite3_value_text(val), "(null)")) {
	        stcsr->isInstanceNULL = 1;
		stcsr->max_size = 1;
                stcsr->size = 1;
		return SQLITE_OK;
            }
	    if (!strcmp((const char *)sqlite3_value_text(val), "(empty)")) {
	        stcsr->isInstanceEmpty = 1;
	        stcsr->max_size = 1;
                stcsr->size = 1;
		return SQLITE_OK;
            }
<%        if $argT == "TYPESAFE" %>
            vtd_iter = vt_directory.find(stl->zName);
            if ((vtd_iter == vt_directory.end()) || (vtd_iter->second == 0)) {
                printf("Invalid cast to %s\n", stl->zName);
                return SQLITE_MISUSE;
            }
            vt_directory[stl->zName] = 0;
<%        end %>
            stcsr->source = (void *)sqlite3_value_int64(val);
	    if (stcsr->source == NULL) {
	        stcsr->isInstanceNULL = 1;
		stcsr->max_size = 1;
                stcsr->size = 1;
		return SQLITE_OK;
            }
	    stcsr->isInstanceNULL = 0;
            any_dstr = (<%= sign_retype %>)stcsr->source;
<%        if @container_class.length > 0 %>
            if ((re = realloc_resultset(cur)) != SQLITE_OK) {
              return re;
            }
	    if (stcsr->isInstanceEmpty) return SQLITE_OK;
<%        else %>
	    stcsr->isInstanceEmpty = 0;
	    stcsr->max_size = 1;
<%        end %>
        }
        size = stcsr->max_size;
<%      end %>
        int *temp_res;
	temp_res = (int *)sqlite3_malloc(sizeof(int)  * size);
        if (!temp_res) {
            printf("Error in allocating memory\n");
            return SQLITE_NOMEM;
        }
