/*                                                         
 *   Implement the filter and projection functions for 
 *   each of the registered virtual tables.
 *                                                         
 *   Copyright 2012 Marios Fragkoulis
 *                                                         
 *   Licensed under the Apache License, Version 2.0        
 *   (the "License");you may not use this file except in   
 *   compliance with the License.                          
 *   You may obtain a copy of the License at               
 *                                                         
 *       http://www.apache.org/licenses/LICENSE-2.0        
 *                                                         
 *   Unless required by applicable law or agreed to in     
 *   writing, software distributed under the License is    
 *   distributed on an "AS IS" BASIS.                      
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either  
 *   express or implied.                                   
 *   See the License for the specific language governing   
 *   permissions and limitations under the License.
 */

#include <cassert>
#include <cstdio>
#include <cstring>
#include <string>
<%     if $argT == "TYPESAFE" %>
#include <map>
<%     end %>
#ifdef PICO_QL_HANDLE_POLYMORPHISM
#include <vector>
#endif
#include <boost/concept_check.hpp>
#ifndef PICO_QL_SINGLE_THREADED
#include <pthread.h>
#endif
<%= directives %>
#include "pico_ql_search.h"
#include "pico_ql_interface.h"
#include "pico_ql_search_helper.h"


using namespace std;
using namespace boost;

template <class T>
void forward_container_concept_check(T x) {
    BOOST_CONCEPT_ASSERT((ForwardContainer<T>));
};

template <class It>
class forward_iterator_concept_class {
    BOOST_CONCEPT_ASSERT((ForwardIterator<It>));
};

struct name_cmp {
    bool operator()(const char *a, const char *b) {
        return strcmp(a, b) < 0;
    }
};

<%     if $argT == "TYPESAFE" %>
static map<const char *, int, name_cmp> vt_directory;
static map<const char *, int, name_cmp>::iterator vtd_iter;
<%     end %>

<%     @tables.each { |vt| %>
<%      if vt.base_var.length > 0 %>
<%        /\*/.match(vt.pointer) == nil ? retype = "*" : retype = "" %>
<%= vt.signature %> <%= retype %><%= vt.base_var %>;
<%      end %>
<%     } %>

/* Registers the base variables of user application code
 * with PiCO QL.
 */
void pico_ql_register(void *data_structure, const char *ds_name) {
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].base_var.length > 0 %>
<%        if count == 0 %>
    if (!strcmp(ds_name, "<%= @tables[vt].base_var %>")) {
<%	  count += 1 %>
<%        else %>
    } else if (!strcmp(ds_name, "<%= @tables[vt].base_var %>")) {
<%        end %>
<%        /\*/.match(@tables[vt].pointer) == nil ? retype = "*" : retype = "" %>
        <%= @tables[vt].base_var %> = (<%= @tables[vt].signature %> <%= retype %>)data_structure;
<%      end %>
<%    } %>
    }
}


// Thread. Creates the queries and passes them on to PiCO_QL.
void * thread_sqlite(void *data) {
    const char **queries, **table_names;
    queries = (const char **)sqlite3_malloc(sizeof(char *) *
                   <%= @tables.length.to_s %>);
    table_names = (const char **)sqlite3_malloc(sizeof(char *) *
                   <%= @tables.length.to_s %>);
    int failure = 0;
<%# <db>.<table> does not work for some reason. test. %>
<%    @tables.each_index { |vt| %>
<%#      query =  "CREATE VIRTUAL TABLE #{@tables[vt].db}.#{@tables[vt].name} USING stl(" %>
<%      query =  "CREATE VIRTUAL TABLE #{@tables[vt].name} USING stl(" %>
<%      @tables[vt].columns.each { |c| %>
<%        query += "#{c.name} #{c.data_type}, " %>
<%      } %>
<%      query = query.chomp(", ") + ")" %>
    queries[<%= vt %>] = "<%= query %>";
    table_names[<%= vt %>] = "<%= @tables[vt].name %>";
<%    } %>
    failure = register_table( "<%= @tables[0].db %>" , <%= @tables.length.to_s %>, queries, table_names, data);
    printf("Thread sqlite returns %i\n", failure);
    sqlite3_free(queries);
    sqlite3_free(table_names);
    return NULL;
}


// The API with user application code. Creates the PiCO_QL thread.
int pico_ql_serve() {
#ifndef PICO_QL_SINGLE_THREADED
    pthread_t sqlite_thread;
    pthread_create(&sqlite_thread, NULL, thread_sqlite, NULL);
#ifdef PICO_QL_JOIN_THREADS
    pthread_join(sqlite_thread, NULL);
#endif
#else
    thread_sqlite(NULL);
#endif
    return 0;
}


/* Registers the base variables of user application code
 * with their virtual table representation.
 */
void register_vt(stlTable *stl) {
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].base_var.length > 0 %>
<%        if count == 0 %>
    if (!strcmp(stl->zName, "<%= @tables[vt].name %>")) {
<%	  count += 1 %>
<%        else %>
    } else if (!strcmp(stl->zName, "<%= @tables[vt].name %>")) {
<%        end %>
<%# Retyping has been taken care of in register_pico_ql %>
<%#        /\*/.match(@tables[vt].pointer) == nil ? retype = "&" : retype = "" %>
        stl->data = (void *)<%= @tables[vt].base_var %>;
        stl->embedded = 0;
<%      end %>
<%    } %>
    } else {
        stl->data = NULL;
        stl->embedded = 1;
    }
<%    if $argT == "TYPESAFE" %>
    vt_directory[stl->zName] = 0;
<%    end %>
}


// Returns the size (records) for each virtual table.
int get_datastructure_size(sqlite3_vtab_cursor *cur) {
    stlTableCursor *stc = (stlTableCursor *)cur;
    stlTable *stl = (stlTable *)cur->pVtab;
<%    count = 0 %>
<%    @tables.each_index { |vt| %>
<%      if @tables[vt].container_class.length > 0 %>
<%        if count == 0 %>
    if (!strcmp(stl->zName, "<%= @tables[vt].name %>")) {
<%	  count += 1 %>
<%        else %>
    } else if (!strcmp(stl->zName, "<%= @tables[vt].name %>")) {
<%        end %>
<%        /\*/.match(@tables[vt].pointer) == nil ? retype = "*" : retype = "" %>
<%# Chomp the pointer from signature. %>
<%# For non-pointers it will have zero effect. %>
        <%= @tables[vt].signature.chomp('*') %> container_instance;
        forward_container_concept_check(container_instance);
        forward_iterator_concept_class<<%= @tables[vt].signature.chomp('*') %>::iterator> it;
	(void)it;	// Silence compiler unised variable warning
<%# stc->source will definitely hold a pointer so retyping the signature as
<%# follows is correct. %>
        <%= @tables[vt].signature %><%= retype %> any_dstr = (<%= @tables[vt].signature %><%= retype %>)stc->source;
        return (int)any_dstr->size();
<%      end %>
<%    } %>
    }
    return 1;
}


// Each embedded virtual table has a column named 'base'.
// This function checks if a provided column name is indeed 'base'.
int equals_base(const char *zCol) {
    int length = (int)strlen(zCol) + 1;
    char copy[length], *token;
    memcpy(copy, zCol, length);
    token = strtok(copy, " ");
    if (token != NULL) {
        if (!strcmp(token, "base"))
            return true;
        else
            return false;
    } else
        return SQLITE_NOMEM;
}


/* Initiates dynamic vector which stores resultset column
 * values of type char array so that they are retrievable
 * by SQLite without conflict.
 */
int init_text_vector(stlTableCursor *stc) {
  vector<string*> *tr = new vector<string*>();
  stc->textResults = (void *)tr;
  if (tr != NULL)
    return SQLITE_OK;
  else
    return SQLITE_NOMEM;
}


/* Deinitiates dynamic vector which stores resultset
 * column values of type char array so that they are
 * retrievable by SQLite without conflict.
 */
int deinit_text_vector(stlTableCursor *stc) {
  vector<string*> *tr = (vector<string*> *)stc->textResults;
  for (size_t i = 0; i<tr->size(); i++)
      delete tr->at(i);
  delete tr;
}
